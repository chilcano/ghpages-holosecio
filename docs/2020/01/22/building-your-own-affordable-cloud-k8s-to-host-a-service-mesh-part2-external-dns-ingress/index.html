<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Building your own affordable K8s to host a Service Mesh - Part 2: External DNS and Ingress | Holistic Security</title>
  <meta name="description" content="With The Systems Thinking Methodology we are able to see any problem in a complete and holistic manner, in fact, The Systems Thinking Methodology allows us to solve complex problems (IT Security, Global Warming, World Poverty, etc.) by considering new factors, elements and variables (usability, trust, quality, risk, etc.) which were not considered initially.">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="Building your own affordable K8s to host a Service Mesh - Part 2: External DNS and Ingress" />
<meta property="og:description" content="In order to get an affordable Kubernetes, every part we&rsquo;re going to use should be affordable too, and ones of the expensive and tricky things are the AWS Elastic Load Balancing (ELB) and the AWS Route 53 (DNS). Fortunately, Kubernetes SIGs are working to address this gap with the Kubernetes ExternalDNS.
But what is the problem?
Apart of it is expensive, the problem is every time I deploy a Service in Kubernetes I have to update and add a new DNS entry in the Cloud Provider&rsquo;s DNS manually. Yes, of course, the process can be automated, but the idea is doing it during the provisioning time. In other words, every developer can publish theirs services adding the DNS name as annotation for that services can be called over Internet.
Yes, Kubernetes brings by default a DNS but this is an internal one and it is only to work resolving DNS names over the Kubernetes Network, not for internet facing services.
The Solution
The Kubernetes ExternalDNS will run a program in our affordable K8s which it will synchronize exposed Kubernetes Services and Ingresses with the Cloud Provider&rsquo;s DNS Service, in this case with AWS Route 53. Below you can view a high level diagram and current status of my Affordable Kubernetes Data Plane, I recommend look at first post about it.
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://holisticsecurity.io/2020/01/22/building-your-own-affordable-cloud-k8s-to-host-a-service-mesh-part2-external-dns-ingress/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-01-22T10:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-01-22T10:00:00&#43;00:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Building your own affordable K8s to host a Service Mesh - Part 2: External DNS and Ingress"/>
<meta name="twitter:description" content="In order to get an affordable Kubernetes, every part we&rsquo;re going to use should be affordable too, and ones of the expensive and tricky things are the AWS Elastic Load Balancing (ELB) and the AWS Route 53 (DNS). Fortunately, Kubernetes SIGs are working to address this gap with the Kubernetes ExternalDNS.
But what is the problem?
Apart of it is expensive, the problem is every time I deploy a Service in Kubernetes I have to update and add a new DNS entry in the Cloud Provider&rsquo;s DNS manually. Yes, of course, the process can be automated, but the idea is doing it during the provisioning time. In other words, every developer can publish theirs services adding the DNS name as annotation for that services can be called over Internet.
Yes, Kubernetes brings by default a DNS but this is an internal one and it is only to work resolving DNS names over the Kubernetes Network, not for internet facing services.
The Solution
The Kubernetes ExternalDNS will run a program in our affordable K8s which it will synchronize exposed Kubernetes Services and Ingresses with the Cloud Provider&rsquo;s DNS Service, in this case with AWS Route 53. Below you can view a high level diagram and current status of my Affordable Kubernetes Data Plane, I recommend look at first post about it.
"/>

  
  
    
  
  
  <link rel="stylesheet" href="https://holisticsecurity.io/css/style-white.css">
  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="https://holisticsecurity.io/images/favicon.ico" />

  
  
  
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-156433649-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
  
  

  <link rel="stylesheet" href="https://holisticsecurity.io/css/custom-cactus-style-white.css">
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://holisticsecurity.io/">
  
    <div id="logo" style="background-image: url(https://holisticsecurity.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>Holistic Security</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#"><i class="fas fa-bars fa-2x"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/post">Blog</a></li>
      
        <li><a href="/taxonomy">Taxonomy</a></li>
      
        <li><a href="/about">About</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  
  <h1 class="posttitle" itemprop="name headline"> Building your own affordable K8s to host a Service Mesh - Part 2: External DNS and Ingress </h1>

  <ul class="post-list">  
      <li class="post-item">
        <div class="meta">
          <time datetime="2020-01-22 10:00:00 &#43;0000 UTC" itemprop="datePublished">2020-01-22</time>
        </div>
        <span>    
          
          
          <div class="article-category">
              
              
              <a class="category-link" href="/categories/cloud">cloud</a>
              
               · 
              <a class="category-link" href="/categories/service-mesh">service-mesh</a>
              
              · 
          </div>
          
          
          <div class="article-tag">
              
              
              <a class="tag-link" href="/tags/aws" rel="tag">aws</a>
              
               · 
              <a class="tag-link" href="/tags/microservice" rel="tag">microservice</a>
              
               · 
              <a class="tag-link" href="/tags/dns" rel="tag">dns</a>
              
               · 
              <a class="tag-link" href="/tags/ingress" rel="tag">ingress</a>
              
               · 
              <a class="tag-link" href="/tags/nginx" rel="tag">nginx</a>
              
          </div>
          
  
        </span>
      </li>  
    </ul>

  <div class="content" itemprop="articleBody">
  
    <p>In order to get an affordable Kubernetes, every part we&rsquo;re going to use should be affordable too, and ones of the expensive and tricky things are the <a href="https://aws.amazon.com/elasticloadbalancing">AWS Elastic Load Balancing (ELB)</a> and the <a href="https://aws.amazon.com/route53">AWS Route 53 (DNS)</a>. Fortunately, Kubernetes SIGs are working to address this gap with the <a href="https://github.com/kubernetes-sigs/external-dns">Kubernetes ExternalDNS</a>.</p>
<h2 id="but-what-is-the-problem">But what is the problem?</h2>
<p>Apart of it is expensive, the problem is every time I deploy a <code>Service</code> in Kubernetes I have to update and add a new DNS entry in the Cloud Provider&rsquo;s DNS manually. Yes, of course, the process can be automated, but the idea is doing it during the provisioning time. In other words, every developer can publish theirs services adding the DNS name as annotation for that services can be called over Internet.
Yes, <a href="https://github.com/kubernetes/dns">Kubernetes brings by default a DNS</a> but this is an internal one and it is only to work resolving DNS names over the Kubernetes Network, not for internet facing services.</p>
<h2 id="the-solution">The Solution</h2>
<p>The Kubernetes ExternalDNS will run a program in our affordable K8s which it will synchronize exposed Kubernetes Services and Ingresses with the Cloud Provider&rsquo;s DNS Service, in this case with AWS Route 53. Below you can view a high level diagram and current status of my <a href="http://holisticsecurity.io/2020/01/16/building-your-own-affordable-cloud-k8s-to-host-a-service-mesh-data-plane">Affordable Kubernetes Data Plane, I recommend look at first post about it</a>.</p>
<p><a href="/assets/img/20200122-service-mesh-01-affordablek8s-aws-arch.png"><img src="/assets/img/20200122-service-mesh-01-affordablek8s-aws-arch.png" alt="Service Mesh hosted using AWS Spot Instances" title="Service Mesh using AWS Spot Instances"></a></p>
<p>Then, let&rsquo;s do it.</p>
<h2 id="steps">Steps</h2>
<h3 id="1-create-a-hosted-zone-in-aws-route-53">1. Create a Hosted Zone in AWS Route 53</h3>
<p>I&rsquo;m going to register the subdomain <code>cloud.holisticsecurity.io</code> of existing Root domain name <code>holisticsecurity.io</code> into AWS Route 53. I&rsquo;ll follow the below AWS Route 53 explanation.</p>
<ul>
<li><a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/creating-migrating.html">Using Amazon Route 53 as the DNS Service for Subdomains Without Migrating the Parent Domain</a></li>
</ul>
<p>You can create subdomain records using either the Amazon Route 53 console or the Route 53 API. Since I have already <code>AWS CLI</code> configured in my PC, then let&rsquo;s use it.</p>
<h4 id="11-create-a-hosted-zone-in-aws-53-for-the-subdomain">1.1. Create a Hosted Zone in AWS 53 for the Subdomain</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># Create a DNS zone which will contain the managed DNS records.</span>
$ aws route53 create-hosted-zone --name <span style="color:#e6db74">&#34;cloud.holisticsecurity.io.&#34;</span> --caller-reference <span style="color:#e6db74">&#34;cloud-holosec-io-</span><span style="color:#66d9ef">$(</span>date +%s<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span> --hosted-zone-config <span style="color:#e6db74">&#34;Comment=&#39;HostedZone for subdomain&#39;,PrivateZone=false&#34;</span>

<span style="color:#75715e"># Get the Hosted Zone ID (HZ_ID) of the hosted zone I just created, which will serve as the value for my-hostedzone-identifier.</span>
$ export HZ_ID<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>aws route53 list-hosted-zones-by-name --output json --dns-name <span style="color:#e6db74">&#34;cloud.holisticsecurity.io.&#34;</span> | jq -r <span style="color:#e6db74">&#39;.HostedZones[0].Id&#39;</span><span style="color:#66d9ef">)</span>

<span style="color:#75715e"># Make a note of the nameservers that were assigned to my new zone.</span>
$ aws route53 list-resource-record-sets --output json --hosted-zone-id <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HZ_ID<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> --query <span style="color:#e6db74">&#34;ResourceRecordSets[?Type == &#39;NS&#39;]&#34;</span> | jq -r <span style="color:#e6db74">&#39;.[0].ResourceRecords[].Value&#39;</span>
ns-1954.awsdns-52.co.uk.
ns-157.awsdns-19.com.
ns-1053.awsdns-03.org.
ns-789.awsdns-34.net.
</code></pre></div><h4 id="12-add-name-server-records-for-the-specified-subdomain-in-the-dns-service-provider-console">1.2. Add <code>Name Server Records</code> for the specified Subdomain in the DNS Service Provider Console</h4>
<p>After changes to Amazon Route 53 records have propagated, the next step is to update the DNS service for the parent domain by adding <code>NS</code> type records for the specified subdomain. This is known as delegating responsibility for the subdomain to Route 53.</p>
<p>I will need the above four nameserver that I got querying with <code>AWSCLI</code>. Note that those nameservers are for my subdomain, likely you got others.</p>
<pre><code>ns-1954.awsdns-52.co.uk.
ns-157.awsdns-19.com.
ns-1053.awsdns-03.org.
ns-789.awsdns-34.net.
</code></pre><p>Finally, for my subdomain <code>cloud.holisticsecurity.io</code>, you should have as shown below:</p>
<pre><code>[...]
cloud 1800 IN NS ns-1053.awsdns-03.org.
cloud 1800 IN NS ns-157.awsdns-19.com.
cloud 1800 IN NS ns-1954.awsdns-52.co.uk.
cloud 1800 IN NS ns-789.awsdns-34.net.
[...]
</code></pre><p>Ah, also you should wait some minutes or hours to propagate these changes. That depends on your DNS Service Provider.</p>
<h3 id="2-provision-of-kubernetes-cluster-with-externaldns-through-terraform">2. Provision of Kubernetes Cluster with ExternalDNS through Terraform</h3>
<p>If you have read the first post about how to create an affordable Kubernetes Data Plane, then you will know that I used Terraform to provision it. I&rsquo;m using the <a href="https://github.com/cablespaghetti/kubeadm-aws">Really cheap Kubernetes cluster on AWS with kubeadm</a> which already uses Kubernetes ExternalDNS, then I&rsquo;m going to re-apply the Terraform scripts activating the installation of ExternalDNS.</p>
<h4 id="21-create-a-fresh-affordable-kubernetes-cluster">2.1. Create a fresh affordable Kubernetes Cluster</h4>
<h5 id="1-clone-the-affordable-k8s-cluster-github-repo">1) Clone the Affordable K8s Cluster Github repo</h5>
<p>If you want a cheap K8s Infrastructure on AWS, I recommend to clone this GitHub repo I&rsquo;ve updated for you.
<a href="https://github.com/chilcano/kubeadm-aws/tree/0.2.1-chilcano">https://github.com/chilcano/kubeadm-aws/tree/0.2.1-chilcano</a></p>
<p>Once cloned, first of all run <code>terraform destroy</code> to remove all AWS resources provisioned previously. TThat will avoid increasing your bill.
After cleaning up, reprovision a fresh Kubernetes Cluster.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ terraform plan <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var cluster-name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;cheapk8s&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var k8s-ssh-key<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ssh-key-for-us-east-1&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var admin-cidr-blocks<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;83.50.9.220/32&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var region<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;us-east-1&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var kubernetes-version<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1.14.3&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var external-dns-enabled<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var nginx-ingress-enabled<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var nginx-ingress-domain<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ingress-nginx.cloud.holisticsecurity.io&#34;</span> 

$ terraform apply <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var cluster-name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;cheapk8s&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var k8s-ssh-key<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ssh-key-for-us-east-1&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var admin-cidr-blocks<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;83.50.9.220/32&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var region<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;us-east-1&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var kubernetes-version<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1.14.3&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var external-dns-enabled<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var nginx-ingress-enabled<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>   -var nginx-ingress-domain<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ingress-nginx.cloud.holisticsecurity.io&#34;</span> 
</code></pre></div><ol start="2">
<li>Clean up unwanted Name Server Records under the AWS Route 53 Hosted Zone for the specified Subdomain.</li>
</ol>
<p>If you have been playing with AWS Route 53 Hosted Zone for the specified Subdomain (<code>cloud.holisticsecurity.io</code>), it&rsquo;s likely you have added records and require removing them before creating fresh records. Then, below I explain you how to do:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># A fresh AWS Route 53 Hosted Zone has 2 records: Record Type NS and Record Type SOA.</span>
$ export MY_SUBDOMAIN<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;cloud.holisticsecurity.io&#34;</span>
$ export HZ_ID<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>aws route53 list-hosted-zones-by-name --dns-name <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>MY_SUBDOMAIN<span style="color:#e6db74">}</span><span style="color:#e6db74">.&#34;</span> | jq -r <span style="color:#e6db74">&#39;.HostedZones[0].Id&#39;</span><span style="color:#66d9ef">)</span>
$ aws route53 list-resource-record-sets --hosted-zone-id $HZ_ID --query <span style="color:#e6db74">&#34;ResourceRecordSets[?Name == &#39;</span><span style="color:#e6db74">${</span>MY_SUBDOMAIN<span style="color:#e6db74">}</span><span style="color:#e6db74">.&#39;].{Name:Name,Type:Type}&#34;</span> | jq -c <span style="color:#e6db74">&#39;.[]&#39;</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Name&#34;</span>:<span style="color:#e6db74">&#34;cloud.holisticsecurity.io.&#34;</span>,<span style="color:#e6db74">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;NS&#34;</span><span style="color:#f92672">}</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Name&#34;</span>:<span style="color:#e6db74">&#34;cloud.holisticsecurity.io.&#34;</span>,<span style="color:#e6db74">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;SOA&#34;</span><span style="color:#f92672">}</span>

<span style="color:#75715e"># I should remove those 10 records (of type A, TXT and SRV) </span>
$ aws route53 list-resource-record-sets --hosted-zone-id $HZ_ID --query <span style="color:#e6db74">&#34;ResourceRecordSets[?Name != &#39;</span><span style="color:#e6db74">${</span>MY_SUBDOMAIN<span style="color:#e6db74">}</span><span style="color:#e6db74">.&#39;].{Name:Name,Type:Type}&#34;</span> | jq -c <span style="color:#e6db74">&#39;.[]&#39;</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Name&#34;</span>:<span style="color:#e6db74">&#34;hello-svc-np.cloud.holisticsecurity.io.&#34;</span>,<span style="color:#e6db74">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">}</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Name&#34;</span>:<span style="color:#e6db74">&#34;hello-svc-np.cloud.holisticsecurity.io.&#34;</span>,<span style="color:#e6db74">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;TXT&#34;</span><span style="color:#f92672">}</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Name&#34;</span>:<span style="color:#e6db74">&#34;_http._tcp.hello-svc-np.cloud.holisticsecurity.io.&#34;</span>,<span style="color:#e6db74">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;SRV&#34;</span><span style="color:#f92672">}</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Name&#34;</span>:<span style="color:#e6db74">&#34;_http._tcp.hello-svc-np.cloud.holisticsecurity.io.&#34;</span>,<span style="color:#e6db74">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;TXT&#34;</span><span style="color:#f92672">}</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Name&#34;</span>:<span style="color:#e6db74">&#34;ingress-nginx.cloud.holisticsecurity.io.&#34;</span>,<span style="color:#e6db74">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">}</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Name&#34;</span>:<span style="color:#e6db74">&#34;ingress-nginx.cloud.holisticsecurity.io.&#34;</span>,<span style="color:#e6db74">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;TXT&#34;</span><span style="color:#f92672">}</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Name&#34;</span>:<span style="color:#e6db74">&#34;_http._tcp.ingress-nginx.cloud.holisticsecurity.io.&#34;</span>,<span style="color:#e6db74">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;SRV&#34;</span><span style="color:#f92672">}</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Name&#34;</span>:<span style="color:#e6db74">&#34;_http._tcp.ingress-nginx.cloud.holisticsecurity.io.&#34;</span>,<span style="color:#e6db74">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;TXT&#34;</span><span style="color:#f92672">}</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Name&#34;</span>:<span style="color:#e6db74">&#34;_https._tcp.ingress-nginx.cloud.holisticsecurity.io.&#34;</span>,<span style="color:#e6db74">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;SRV&#34;</span><span style="color:#f92672">}</span>
<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Name&#34;</span>:<span style="color:#e6db74">&#34;_https._tcp.ingress-nginx.cloud.holisticsecurity.io.&#34;</span>,<span style="color:#e6db74">&#34;Type&#34;</span>:<span style="color:#e6db74">&#34;TXT&#34;</span><span style="color:#f92672">}</span>

<span style="color:#75715e"># Removing those unwanted records.</span>
$ aws route53 list-resource-record-sets --hosted-zone-id $HZ_ID --query <span style="color:#e6db74">&#34;ResourceRecordSets[?Name != &#39;</span><span style="color:#e6db74">${</span>MY_SUBDOMAIN<span style="color:#e6db74">}</span><span style="color:#e6db74">.&#39;]&#34;</span> | jq -c <span style="color:#e6db74">&#39;.[]&#39;</span> |
   <span style="color:#66d9ef">while</span> read -r RRS; <span style="color:#66d9ef">do</span>
      read -r name type <span style="color:#f92672">&lt;&lt;&lt;</span> <span style="color:#66d9ef">$(</span>jq -jr <span style="color:#e6db74">&#39;.Name, &#34; &#34;, .Type&#39;</span> <span style="color:#f92672">&lt;&lt;&lt;</span> <span style="color:#e6db74">&#34;</span>$RRS<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span> 
      CHG_ID<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>aws route53 change-resource-record-sets --hosted-zone-id $HZ_ID --change-batch <span style="color:#e6db74">&#39;{&#34;Changes&#34;:[{&#34;Action&#34;:&#34;DELETE&#34;,&#34;ResourceRecordSet&#34;: &#39;</span><span style="color:#e6db74">&#34;</span>$RRS<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">&#39; }]}&#39;</span> --output text --query <span style="color:#e6db74">&#39;ChangeInfo.Id&#39;</span><span style="color:#66d9ef">)</span>
      echo <span style="color:#e6db74">&#34; - DELETING: </span>$type<span style="color:#e6db74"> </span>$name<span style="color:#e6db74"> - CHANGE ID: </span>$CHG_ID<span style="color:#e6db74">&#34;</span>    
   <span style="color:#66d9ef">done</span>

   - DELETING: TXT ccc.cloud.holisticsecurity.io. - CHANGE ID: /change/CMCJ8CXRBIZ7M
   - DELETING: SRV ddd.cloud.holisticsecurity.io. - CHANGE ID: /change/C2KU4TEHWEDV2Y
</code></pre></div><p>Only if it is required, you can delete the AWS Hosted Zone in this way:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ aws route53 delete-hosted-zone --id $HZ_ID --output text --query <span style="color:#e6db74">&#39;ChangeInfo.Id&#39;</span>
</code></pre></div><h4 id="22-verify-externaldns-has-synchronized-the-ingress-subdomain-with-aws-route-53">2.2. Verify ExternalDNS has synchronized the Ingress' subdomain with AWS Route 53</h4>
<p>The domain name that the Ingress' subdomain will request is <code>ingress-nginx.cloud.holisticsecurity.io</code>, that domain name has been created during the Affordable K8s Cluster creation. Then, let&rsquo;s check it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ export MY_SUBDOMAIN<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;cloud.holisticsecurity.io&#34;</span>
$ export INGRESS_NS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ingress-nginx.</span><span style="color:#e6db74">${</span>MY_SUBDOMAIN<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>

<span style="color:#75715e"># Get the Hosted Zone (HZ_ID) ID of the hosted zone I just created.</span>
$ export HZ_ID<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>aws route53 list-hosted-zones-by-name --dns-name <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>MY_SUBDOMAIN<span style="color:#e6db74">}</span><span style="color:#e6db74">.&#34;</span> | jq -r <span style="color:#e6db74">&#39;.HostedZones[0].Id&#39;</span><span style="color:#66d9ef">)</span>

<span style="color:#75715e"># Get all nameservers that were assigned initially and recently synchronized by ExternalDNS to my new zone.</span>
$ aws route53 list-resource-record-sets --output text --hosted-zone-id <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HZ_ID<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> --query <span style="color:#e6db74">&#34;ResourceRecordSets[?Name == &#39;</span><span style="color:#e6db74">${</span>INGRESS_NS<span style="color:#e6db74">}</span><span style="color:#e6db74">.&#39;].{Name:Name,Type:Type}&#34;</span>

ingress-nginx.cloud.holisticsecurity.io.	A
ingress-nginx.cloud.holisticsecurity.io.	TXT
</code></pre></div><p>Or if you are of the old-school, you can ask to any of four AWS Route 53&rsquo;s DNS server if the subdomain has been created and updated.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ dig +short @ns-1954.awsdns-52.co.uk. ingress-nginx.cloud.holisticsecurity.io.
174.129.123.159
54.159.75.179

$ dig +short @ns-157.awsdns-19.com. ingress-nginx.cloud.holisticsecurity.io.
174.129.123.159
54.159.75.179

$ dig +short @ns-1053.awsdns-03.org. ingress-nginx.cloud.holisticsecurity.io.
174.129.123.159
54.159.75.179

$ dig +short @ns-789.awsdns-34.net. ingress-nginx.cloud.holisticsecurity.io.
174.129.123.159
54.159.75.179
</code></pre></div><p>Both above IP addresses are the <code>IPv4 Public IP</code> addresses assigned to Kubernetes Master Node and Kubernetes Worker Node. If I add a new Node to existing Kubernetes Cluster, the <code>NGINX Ingress Controller</code> will be installed in the new Node and its new <code>IPv4 Public IP</code> address will resolve to <code>ingress-nginx.cloud.holisticsecurity.io</code>, that is why the <code>NGINX Ingress Controller</code> was deployed into Kubernetes as a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/"><code>DaemonSet</code></a>. Let&rsquo;s to verify it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># Get SSH access to K8s master node</span>
$ ssh ubuntu@<span style="color:#66d9ef">$(</span>terraform output master_dns<span style="color:#66d9ef">)</span> -i ~/Downloads/ssh-key-for-us-east-1.pem

ubuntu@ip-10-0-100-4:~$ kubectl get daemonset -n ingress-nginx
NAME                       DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
nginx-ingress-controller   <span style="color:#ae81ff">2</span>         <span style="color:#ae81ff">2</span>         <span style="color:#ae81ff">2</span>       <span style="color:#ae81ff">2</span>            <span style="color:#ae81ff">2</span>           &lt;none&gt;          14h

ubuntu@ip-10-0-100-4:~$ kubectl get pods -n ingress-nginx -o wide
NAME                                    READY   STATUS    RESTARTS   AGE   IP            NODE                          NOMINATED NODE   READINESS GATES
default-http-backend-5c9bb94849-pf5pj   1/1     Running   <span style="color:#ae81ff">0</span>          14h   10.244.1.3    ip-10-0-100-22.ec2.internal   &lt;none&gt;           &lt;none&gt;
nginx-ingress-controller-bwhdp          1/1     Running   <span style="color:#ae81ff">0</span>          14h   10.0.100.22   ip-10-0-100-22.ec2.internal   &lt;none&gt;           &lt;none&gt;
nginx-ingress-controller-q4bgh          1/1     Running   <span style="color:#ae81ff">0</span>          14h   10.0.100.4    ip-10-0-100-4.ec2.internal    &lt;none&gt;           &lt;none&gt;
</code></pre></div><h4 id="23-verify-externaldns-and-nginx-ingress-work-together-health-check-example">2.3. Verify ExternalDNS and NGINX Ingress work together (Health Check example)</h4>
<p>Since the <code>CheapK8s</code> only exposes RESTful services over <code>80</code> and <code>443</code> ports, then to verify that I need to call the <code>Health Check</code> service of my <a href="https://github.com/chilcano/kubeadm-aws/blob/0.2.1-chilcano/manifests/nginx-ingress-mandatory.yaml">NGINX Ingress Controller</a> deployed through Terraform in previous step. This procedure also verify that the <code>NGINX Ingress Controller</code> has got a DNS name (subdomain <code>ingress-nginx.cloud.holisticsecurity.io</code>) from <code>ExternalDNS</code> successfully. This part has been configured in the file <a href="https://github.com/chilcano/kubeadm-aws/blob/0.2.1-chilcano/manifests/nginx-ingress-nodeport.yaml.tmpl"><code>manifests/nginx-ingress-nodeport.yaml.tmpl</code></a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ curl -X GET http://ingress-nginx.cloud.holisticsecurity.io/healthz -v

Note: Unnecessary use of -X or --request, GET is already inferred.
*   Trying 174.129.123.159:80...
* TCP_NODELAY set
* Connected to ingress-nginx.cloud.holisticsecurity.io <span style="color:#f92672">(</span>174.129.123.159<span style="color:#f92672">)</span> port <span style="color:#ae81ff">80</span> <span style="color:#f92672">(</span><span style="color:#75715e">#0)</span>
&gt; GET /healthz HTTP/1.1
&gt; Host: ingress-nginx.cloud.holisticsecurity.io
&gt; User-Agent: curl/7.65.3
&gt; Accept: */*
&gt; 
* Mark bundle as not supporting multiuse
&lt; HTTP/1.1 <span style="color:#ae81ff">200</span> OK
&lt; Server: nginx/1.15.5
&lt; Date: Tue, <span style="color:#ae81ff">21</span> Jan <span style="color:#ae81ff">2020</span> 21:24:45 GMT
&lt; Content-Type: text/html
&lt; Content-Length: <span style="color:#ae81ff">0</span>
&lt; Connection: keep-alive
&lt; 
* Connection <span style="color:#75715e">#0 to host ingress-nginx.cloud.holisticsecurity.io left intact</span>
</code></pre></div><h4 id="24-verify-externaldns-and-nginx-ingress-work-together-service-example">2.4. Verify ExternalDNS and NGINX Ingress work together (Service example)</h4>
<h5 id="1-deploy-hello-microservice-and-check-the-deployment-status">1) Deploy Hello Microservice and check the deployment status</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># Get SSH access to K8s master node</span>
$ ssh ubuntu@<span style="color:#66d9ef">$(</span>terraform output master_dns<span style="color:#66d9ef">)</span> -i ~/Downloads/ssh-key-for-us-east-1.pem

<span style="color:#75715e"># Deploy Hello microservices</span>
ubuntu@ip-10-0-100-4:~$ kubectl apply -f https://raw.githubusercontent.com/chilcano/kubeadm-aws/0.2.1-chilcano/examples/hello-cheapk8s-app.yaml
namespace/hello created
serviceaccount/hello-sa created
deployment.extensions/hello-v1 created
deployment.extensions/hello-v2 created

<span style="color:#75715e"># Create ClusterIP, LoadBalancer and NodePort Services for above Hello microservices</span>
ubuntu@ip-10-0-100-4:~$ kubectl apply -f https://raw.githubusercontent.com/chilcano/kubeadm-aws/0.2.1-chilcano/examples/hello-cheapk8s-svc.yaml
service/hello-svc-cip created
service/hello-svc-lb created
service/hello-svc-np created

<span style="color:#75715e"># Create 2 Ingress Resources for above ClusterIP and NodePort Services</span>
ubuntu@ip-10-0-100-4:~$ kubectl apply -f https://raw.githubusercontent.com/chilcano/kubeadm-aws/0.2.1-chilcano/examples/hello-cheapk8s-ingress.yaml
ingress.extensions/hello-ingress-cip created
ingress.extensions/hello-ingress-np created

<span style="color:#75715e"># Get status</span>
ubuntu@ip-10-0-100-4:~$ kubectl get pod,svc,ingress -n hello -o wide
NAME                            READY   STATUS    RESTARTS   AGE   IP            NODE                          NOMINATED NODE   READINESS GATES
pod/hello-v1-66fc9c7d98-7b4b5   1/1     Running   <span style="color:#ae81ff">0</span>          32m   10.244.1.16   ip-10-0-100-22.ec2.internal   &lt;none&gt;           &lt;none&gt;
pod/hello-v1-66fc9c7d98-kb2kn   1/1     Running   <span style="color:#ae81ff">0</span>          32m   10.244.1.17   ip-10-0-100-22.ec2.internal   &lt;none&gt;           &lt;none&gt;
pod/hello-v2-845749f774-fzg5f   1/1     Running   <span style="color:#ae81ff">0</span>          32m   10.244.1.18   ip-10-0-100-22.ec2.internal   &lt;none&gt;           &lt;none&gt;
pod/hello-v2-845749f774-q9bk5   1/1     Running   <span style="color:#ae81ff">0</span>          31m   10.244.1.19   ip-10-0-100-22.ec2.internal   &lt;none&gt;           &lt;none&gt;

NAME                    TYPE           CLUSTER-IP      EXTERNAL-IP   PORT<span style="color:#f92672">(</span>S<span style="color:#f92672">)</span>          AGE   SELECTOR
service/hello-svc-cip   ClusterIP      10.108.175.6    &lt;none&gt;        5080/TCP         22m   app<span style="color:#f92672">=</span>hello
service/hello-svc-lb    LoadBalancer   10.102.10.180   &lt;pending&gt;     5080:32379/TCP   22m   app<span style="color:#f92672">=</span>hello
service/hello-svc-np    NodePort       10.105.22.106   &lt;none&gt;        5080:31002/TCP   22m   app<span style="color:#f92672">=</span>hello

NAME                                   HOSTS                                     ADDRESS   PORTS   AGE
ingress.extensions/hello-ingress-cip   ingress-nginx.cloud.holisticsecurity.io             <span style="color:#ae81ff">80</span>      17m
ingress.extensions/hello-ingress-np    hello-svc-np.cloud.holisticsecurity.io              <span style="color:#ae81ff">80</span>      17m
</code></pre></div><h5 id="2-understanding-how-works-microservice-exposition-and-how-they-should-be-called">2) Understanding how works microservice exposition and how they should be called</h5>
<p>Since the <code>ExternalDNS</code> and <code>NGINX Ingress Controller</code> have been configured in the <code>CheapK8s</code> Cluster, the only way to call the <a href="https://github.com/chilcano/kubeadm-aws/blob/0.2.1-chilcano/examples/hello-cheapk8s-app.yaml">Hello Microservices</a> and their <a href="https://github.com/chilcano/kubeadm-aws/blob/0.2.1-chilcano/examples/hello-cheapk8s-svc.yaml"><code>Services</code></a>.</p>
<p>It is very important to understand how Kubernetes exposes our microservices. Next, I copy some concepts (Kubernetes' primitives) and references to understand the whole operation.</p>
<ul>
<li><code>ClusterIP</code>: Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default <code>ServiceType</code>.</li>
<li><code>LoadBalancer</code>: Exposes the Service externally using a cloud provider’s load balancer. <code>NodePort</code> and <code>ClusterIP</code> Services, to which the external load balancer routes, are automatically created.</li>
<li><code>NodePort</code>: Exposes the Service on each Node’s IP at a static port (the <code>NodePort</code>). A <code>ClusterIP</code> Service, to which the <code>NodePort</code> Service routes, is automatically created. You’ll be able to contact the <code>NodePort</code> Service, from outside the cluster, by requesting <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>.</li>
</ul>
<p>Info: <a href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types">Kubernetes - Publishing Services (ServiceTypes)</a></p>
<p>And this is my favorite one.<br>
The Hardest Part of Microservices: Calling Your Services by Christian Posta, 2017/April/25](<a href="https://blog.christianposta.com/microservices/the-hardest-part-of-microservices-calling-your-services">https://blog.christianposta.com/microservices/the-hardest-part-of-microservices-calling-your-services</a>)</p>
<h5 id="3-calling-hello-microservices">3) Calling Hello Microservices</h5>
<p>Calling through Services (ClusterIP, LoadBalancer and NodePort) from inside of Kubernetes Cluster. Although below I&rsquo;m using <code>ClusterIP</code>, you can repeat similar process using the <code>LoadBalancer</code> and <code>NodePort</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ kubectl get svc/hello-svc-cip -o jsonpath<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;{.spec.clusterIP}&#39;</span>
$ kubectl get svc/hello-svc-cip -o jsonpath<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;{.spec.ports[0].port}&#39;</span>
$ export HELLO_SVC_CIP<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>kubectl get svc/hello-svc-cip -n hello -o jsonpath<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;{.spec.clusterIP}&#39;</span><span style="color:#66d9ef">)</span>:<span style="color:#66d9ef">$(</span>kubectl get svc/hello-svc-cip -n hello -o jsonpath<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;{.spec.ports[0].port}&#39;</span><span style="color:#66d9ef">)</span>
$ echo $HELLO_SVC_CIP

$ curl http://<span style="color:#e6db74">${</span>HELLO_SVC_CIP<span style="color:#e6db74">}</span>/hello
Hello version: v1, instance: hello-v1-5cb886df9d-k7rcq

$ curl http://<span style="color:#e6db74">${</span>HELLO_SVC_CIP<span style="color:#e6db74">}</span>/hello
Hello version: v2, instance: hello-v2-6c7fbbb654-kq6sq

$ curl http://<span style="color:#e6db74">${</span>HELLO_SVC_CIP<span style="color:#e6db74">}</span>/hello
Hello version: v1, instance: hello-v1-5cb886df9d-k7rcq

$ kubectl logs -f -l app<span style="color:#f92672">=</span>hello -n hello
   * Running on http://0.0.0.0:5000/ <span style="color:#f92672">(</span>Press CTRL+C to quit<span style="color:#f92672">)</span>
   * Running on http://0.0.0.0:5000/ <span style="color:#f92672">(</span>Press CTRL+C to quit<span style="color:#f92672">)</span>
10.244.0.0 - - <span style="color:#f92672">[</span>22/Jan/2020 11:20:45<span style="color:#f92672">]</span> <span style="color:#e6db74">&#34;GET /hello HTTP/1.1&#34;</span> <span style="color:#ae81ff">200</span> -
10.244.0.0 - - <span style="color:#f92672">[</span>22/Jan/2020 11:22:27<span style="color:#f92672">]</span> <span style="color:#e6db74">&#34;GET /hello HTTP/1.1&#34;</span> <span style="color:#ae81ff">200</span> -
10.244.0.0 - - <span style="color:#f92672">[</span>22/Jan/2020 11:22:33<span style="color:#f92672">]</span> <span style="color:#e6db74">&#34;GET /hello HTTP/1.1&#34;</span> <span style="color:#ae81ff">200</span> -
</code></pre></div><p>Calling from Internet through Kubernetes Ingress Controller and its Fully Qualified Domain Name (<code>FQDN</code>).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ curl http://ingress-nginx.cloud.holisticsecurity.io/hello
Hello version: v2, instance: hello-v2-845749f774-q9bk5

$ curl http://hello-svc-np.cloud.holisticsecurity.io/hello
Hello version: v1, instance: hello-v1-66fc9c7d98-7b4b5
</code></pre></div><h2 id="references">References</h2>
<ol>
<li><a href="https://github.com/kubernetes-sigs/external-dns">Kubernetes SIGs ExternalDNS&rsquo;s github repo</a></li>
<li><a href="https://www.youtube.com/watch?v=9HQ2XgL9YVI">The missing piece - Kubernetes ExternalDNS by Lachlan Evenson, 2017/Aug/09</a></li>
<li><a href="https://github.com/kubernetes/ingress-nginx">The NGINX Ingress Controller</a></li>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/service/">Kubernetes concepts - Service</a></li>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Kubernetes concepts - Ingress</a></li>
<li><a href="https://blog.christianposta.com/microservices/the-hardest-part-of-microservices-calling-your-services">The Hardest Part of Microservices: Calling Your Services by Christian Posta, 2017/April/25</a></li>
</ol>
<p>In the next blog post I&rsquo;ll explain how to generate TLS Certificates for your Microservices.
Stay tuned.</p>
  
  </div>
</article>


    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2021  Holistic Security 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
         
        <li><a href="/post">Blog</a></li>
         
        <li><a href="/taxonomy">Taxonomy</a></li>
         
        <li><a href="/about">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-156433649-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
